{
  "doc_meta": {
    "id": "AI-001",
    "version": "2025-01-14",
    "owners": ["pablo"],
    "scope": ["ai", "openai", "gpt-4o"],
    "related": ["API-001", "COMP-001"]
  }
}

# StayPost AI í†µí•© ê°€ì´ë“œ

ì´ ë¬¸ì„œëŠ” StayPost í”„ë¡œì íŠ¸ì˜ AI ì„œë¹„ìŠ¤ í†µí•© ë°©ë²•ê³¼ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## ğŸ“‹ ëª©ì°¨
- [ê°œìš”](#ê°œìš”)
- [AI ì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜](#ai-ì„œë¹„ìŠ¤-ì•„í‚¤í…ì²˜)
- [OpenAI GPT-4o í†µí•©](#openai-gpt-4o-í†µí•©)
- [í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§](#í”„ë¡¬í”„íŠ¸-ì—”ì§€ë‹ˆì–´ë§)
- [ì´ë¯¸ì§€ ë¶„ì„](#ì´ë¯¸ì§€-ë¶„ì„)
- [ì—ëŸ¬ ì²˜ë¦¬](#ì—ëŸ¬-ì²˜ë¦¬)
- [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
- [ë¹„ìš© ê´€ë¦¬](#ë¹„ìš©-ê´€ë¦¬)

## ğŸ—ï¸ ì•„í‚¤í…ì²˜
<!-- ì•„í‚¤í…ì²˜ ê´€ë ¨ ë‚´ìš© -->

## ğŸ”Œ API
<!-- API ê´€ë ¨ ë‚´ìš© -->

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤
<!-- ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨ ë‚´ìš© -->

## ğŸ¨ ì»´í¬ë„ŒíŠ¸
<!-- ì»´í¬ë„ŒíŠ¸ ê´€ë ¨ ë‚´ìš© -->

## ğŸ”„ ìƒíƒœ ê´€ë¦¬
<!-- ìƒíƒœ ê´€ë¦¬ ê´€ë ¨ ë‚´ìš© -->

## ğŸš€ ë°°í¬
<!-- ë°°í¬ ê´€ë ¨ ë‚´ìš© -->

## ğŸ› ë¬¸ì œ í•´ê²°
<!-- ë¬¸ì œ í•´ê²° ê´€ë ¨ ë‚´ìš© -->

## ğŸ”® í–¥í›„ ê³„íš
<!-- í–¥í›„ ê³„íš ê´€ë ¨ ë‚´ìš© -->

## ê°œìš”

StayPostëŠ” OpenAI GPT-4oë¥¼ í•µì‹¬ AI ì„œë¹„ìŠ¤ë¡œ ì‚¬ìš©í•˜ì—¬ ê°ì • ê¸°ë°˜ ìº¡ì…˜ ìƒì„±ê³¼ ì´ë¯¸ì§€ ë¶„ì„ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ì— ë§ëŠ” ê°œì¸í™”ëœ SNS ì½˜í…ì¸ ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.

## AI ì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜

### ì „ì²´ AI í”Œë¡œìš°

```mermaid
flowchart LR
  A[ì´ë¯¸ì§€ ì—…ë¡œë“œ] --> B[ì´ë¯¸ì§€ ë¶„ì„]
  B --> C[ê°ì • ì„ íƒ]
  C --> D[ìº¡ì…˜ ìƒì„±]
  D --> E[SEO ë©”íƒ€ë°ì´í„° ìƒì„±]
  E --> F[ìµœì¢… ì½˜í…ì¸ ]
```

### AI ì„œë¹„ìŠ¤ êµ¬ì„±

```
AI Services
â”œâ”€â”€ OpenAI GPT-4o
â”‚   â”œâ”€â”€ ìº¡ì…˜ ìƒì„±
â”‚   â”œâ”€â”€ ì´ë¯¸ì§€ ë¶„ì„
â”‚   â””â”€â”€ SEO ë©”íƒ€ë°ì´í„° ìƒì„±
â”œâ”€â”€ ClipDrop API (ì„ íƒì‚¬í•­)
â”‚   â””â”€â”€ ì´ë¯¸ì§€ ë¦¬í„°ì¹­
â””â”€â”€ ë¡œì»¬ ì´ë¯¸ì§€ ì²˜ë¦¬
    â”œâ”€â”€ ì´ë¯¸ì§€ ì••ì¶•
    â””â”€â”€ í¬ë§· ë³€í™˜
```

## OpenAI GPT-4o í†µí•©

### ê¸°ë³¸ ì„¤ì •

```typescript
// lib/openai.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  dangerouslyAllowBrowser: false // ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ í˜¸ì¶œ ë°©ì§€
});

export default openai;
```

### ìº¡ì…˜ ìƒì„± í•¨ìˆ˜

```typescript
// utils/generateCaption.ts
export async function generateCaption(params: {
  emotion: string;
  templateId: string;
  storeName: string;
  placeDesc?: string;
}): Promise<{
  hook: string;
  caption: string;
  hashtags: string[];
}> {
  const { emotion, templateId, storeName, placeDesc } = params;
  
  const prompt = buildCaptionPrompt({
    emotion,
    templateId,
    storeName,
    placeDesc
  });

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "ë‹¹ì‹ ì€ ìˆ™ë°•ì—…ì†Œ SNS ë§ˆì¼€íŒ… ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ê°ì •ì ì´ê³  ë§¤ë ¥ì ì¸ ìº¡ì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    const response = completion.choices[0]?.message?.content;
    return parseCaptionResponse(response);
  } catch (error) {
    console.error('OpenAI API Error:', error);
    throw new Error('ìº¡ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
  }
}
```

### ì´ë¯¸ì§€ ë¶„ì„ í•¨ìˆ˜

```typescript
// utils/generateImageMeta.ts
export async function generateImageMeta(imageBase64: string): Promise<{
  main_features: string[];
  view_type: string;
  emotions: string[];
  hashtags: string[];
}> {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ìˆ™ë°•ì—…ì†Œ ë§ˆì¼€íŒ…ì— í•„ìš”í•œ ì •ë³´ë¥¼ ì¶”ì¶œí•´ì£¼ì„¸ìš”."
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: "ì´ ìˆ™ë°•ì—…ì†Œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ ì •ë³´ë¥¼ ì œê³µí•´ì£¼ì„¸ìš”: ì£¼ìš” íŠ¹ì§•, ë·° íƒ€ì…, ê°ì •ì  ë¶„ìœ„ê¸°, í•´ì‹œíƒœê·¸"
            },
            {
              type: "image_url",
              image_url: {
                url: `data:image/jpeg;base64,${imageBase64}`
              }
            }
          ]
        }
      ],
      temperature: 0.3,
      max_tokens: 300
    });

    const response = completion.choices[0]?.message?.content;
    return parseImageMetaResponse(response);
  } catch (error) {
    console.error('Image Analysis Error:', error);
    throw new Error('ì´ë¯¸ì§€ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
  }
}
```

## í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§

### ìº¡ì…˜ ìƒì„± í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿

```typescript
// utils/promptTemplates.ts
export function buildCaptionPrompt(params: {
  emotion: string;
  templateId: string;
  storeName: string;
  placeDesc?: string;
}): string {
  const { emotion, templateId, storeName, placeDesc } = params;
  
  const emotionContext = getEmotionContext(emotion);
  const templateStyle = getTemplateStyle(templateId);
  
  return `
ìˆ™ë°•ì—…ì†Œ "${storeName}"ì˜ SNS ìº¡ì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”.

ê°ì •: ${emotion}
${emotionContext}

ìŠ¤íƒ€ì¼: ${templateStyle}

${placeDesc ? `ì¥ì†Œ ì„¤ëª…: ${placeDesc}` : ''}

ìš”êµ¬ì‚¬í•­:
1. ê°ì •ì— ë§ëŠ” í†¤ì•¤ë§¤ë„ˆë¡œ ì‘ì„±
2. 2-3ë¬¸ì¥ìœ¼ë¡œ êµ¬ì„±
3. ì´ëª¨ì§€ 1-2ê°œ í¬í•¨
4. í•´ì‹œíƒœê·¸ 3-5ê°œ ìƒì„±

ì¶œë ¥ í˜•ì‹:
í›…: [ë§¤ë ¥ì ì¸ ì²« ë¬¸ì¥]
ìº¡ì…˜: [ë³¸ë¬¸ ë‚´ìš©]
í•´ì‹œíƒœê·¸: [í•´ì‹œíƒœê·¸ ëª©ë¡]
`;
}

function getEmotionContext(emotion: string): string {
  const contexts = {
    'ì„¤ë ˜': 'ê¸°ëŒ€ê°ê³¼ ì„¤ë ˜ì„ ëŠë‚„ ìˆ˜ ìˆëŠ” ë¶„ìœ„ê¸°',
    'í‰ì˜¨': 'ì°¨ë¶„í•˜ê³  í‰í™”ë¡œìš´ ë¶„ìœ„ê¸°',
    'ì¦ê±°ì›€': 'í™œê¸°ì°¨ê³  ì¦ê±°ìš´ ë¶„ìœ„ê¸°',
    'ë¡œë§¨í‹±': 'ë¡œë§¨í‹±í•˜ê³  ì•„ë¦„ë‹¤ìš´ ë¶„ìœ„ê¸°',
    'íë§': 'í¸ì•ˆí•˜ê³  íë§ë˜ëŠ” ë¶„ìœ„ê¸°'
  };
  return contexts[emotion] || contexts['í‰ì˜¨'];
}

function getTemplateStyle(templateId: string): string {
  const styles = {
    'default_universal': 'ì¼ë°˜ì ì¸ SNS ìŠ¤íƒ€ì¼',
    'ocean_sunset': 'ì˜¤ì…˜ ì„ ì…‹ ë¶„ìœ„ê¸°',
    'luxury_pool': 'ëŸ­ì…”ë¦¬ í’€ ë¶„ìœ„ê¸°',
    'cafe_cozy': 'ì¹´í˜ ì½”ì§€ ë¶„ìœ„ê¸°'
  };
  return styles[templateId] || styles['default_universal'];
}
```

### ì‘ë‹µ íŒŒì‹± í•¨ìˆ˜

```typescript
// utils/parseCaptionResponse.ts
export function parseCaptionResponse(response: string): {
  hook: string;
  caption: string;
  hashtags: string[];
} {
  try {
    // ì •ê·œì‹ì„ ì‚¬ìš©í•˜ì—¬ ì‘ë‹µ íŒŒì‹±
    const hookMatch = response.match(/í›…:\s*(.+)/);
    const captionMatch = response.match(/ìº¡ì…˜:\s*(.+)/);
    const hashtagsMatch = response.match(/í•´ì‹œíƒœê·¸:\s*(.+)/);

    const hook = hookMatch?.[1]?.trim() || '';
    const caption = captionMatch?.[1]?.trim() || '';
    const hashtagsText = hashtagsMatch?.[1]?.trim() || '';

    // í•´ì‹œíƒœê·¸ íŒŒì‹±
    const hashtags = hashtagsText
      .split(/[,\s]+/)
      .map(tag => tag.trim())
      .filter(tag => tag.startsWith('#'))
      .slice(0, 5);

    return {
      hook: hook || caption.split('.')[0] + '.',
      caption: caption || response,
      hashtags: hashtags.length > 0 ? hashtags : ['#ìˆ™ë°•ì—…ì†Œ', '#ì—¬í–‰', '#íë§']
    };
  } catch (error) {
    console.error('Response parsing error:', error);
    return {
      hook: response.split('.')[0] + '.',
      caption: response,
      hashtags: ['#ìˆ™ë°•ì—…ì†Œ', '#ì—¬í–‰', '#íë§']
    };
  }
}
```

## ì´ë¯¸ì§€ ë¶„ì„

### ì´ë¯¸ì§€ ì „ì²˜ë¦¬

```typescript
// utils/imageProcessing.ts
export async function preprocessImage(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    img.onload = () => {
      // ì´ë¯¸ì§€ í¬ê¸° ì¡°ì • (ìµœëŒ€ 1024px)
      const maxSize = 1024;
      let { width, height } = img;
      
      if (width > height) {
        if (width > maxSize) {
          height = (height * maxSize) / width;
          width = maxSize;
        }
      } else {
        if (height > maxSize) {
          width = (width * maxSize) / height;
          height = maxSize;
        }
      }

      canvas.width = width;
      canvas.height = height;
      
      // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
      ctx?.drawImage(img, 0, 0, width, height);
      
      // JPEGë¡œ ë³€í™˜ (í’ˆì§ˆ 0.8)
      const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
      const base64 = dataUrl.split(',')[1];
      
      resolve(base64);
    };

    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
}
```

### ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° íŒŒì‹±

```typescript
// utils/parseImageMetaResponse.ts
export function parseImageMetaResponse(response: string): {
  main_features: string[];
  view_type: string;
  emotions: string[];
  hashtags: string[];
} {
  try {
    // JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µì„ íŒŒì‹±
    const lines = response.split('\n');
    const result = {
      main_features: [],
      view_type: '',
      emotions: [],
      hashtags: []
    };

    for (const line of lines) {
      if (line.includes('ì£¼ìš” íŠ¹ì§•:')) {
        result.main_features = line.split(':')[1]?.split(',').map(f => f.trim()) || [];
      } else if (line.includes('ë·° íƒ€ì…:')) {
        result.view_type = line.split(':')[1]?.trim() || '';
      } else if (line.includes('ê°ì •:')) {
        result.emotions = line.split(':')[1]?.split(',').map(e => e.trim()) || [];
      } else if (line.includes('í•´ì‹œíƒœê·¸:')) {
        result.hashtags = line.split(':')[1]?.split(',').map(h => h.trim()) || [];
      }
    }

    return result;
  } catch (error) {
    console.error('Image meta parsing error:', error);
    return {
      main_features: ['ìˆ™ë°•ì—…ì†Œ'],
      view_type: 'ì¼ë°˜',
      emotions: ['í¸ì•ˆí•¨'],
      hashtags: ['#ìˆ™ë°•ì—…ì†Œ', '#ì—¬í–‰']
    };
  }
}
```

## ì—ëŸ¬ ì²˜ë¦¬

### AI ì„œë¹„ìŠ¤ ì—ëŸ¬ ì²˜ë¦¬

```typescript
// utils/aiErrorHandler.ts
export class AIError extends Error {
  constructor(
    message: string,
    public code: string,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AIError';
  }
}

export function handleAIError(error: any): AIError {
  if (error instanceof AIError) {
    return error;
  }

  // OpenAI API ì—ëŸ¬ ì²˜ë¦¬
  if (error?.response?.status) {
    switch (error.response.status) {
      case 401:
        return new AIError('API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'INVALID_API_KEY');
      case 429:
        return new AIError('ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'RATE_LIMIT', true);
      case 500:
        return new AIError('AI ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'AI_SERVICE_ERROR', true);
      default:
        return new AIError('AI ì„œë¹„ìŠ¤ í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'UNKNOWN_ERROR');
    }
  }

  // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬
  if (error.name === 'TypeError' && error.message.includes('fetch')) {
    return new AIError('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.', 'NETWORK_ERROR', true);
  }

  return new AIError('ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'UNKNOWN_ERROR');
}
```

### ì¬ì‹œë„ ë¡œì§

```typescript
// utils/retry.ts
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt === maxRetries) {
        throw lastError;
      }

      // ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬ì¸ì§€ í™•ì¸
      if (error instanceof AIError && !error.retryable) {
        throw error;
      }

      // ì§€ìˆ˜ ë°±ì˜¤í”„
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}
```

## ì„±ëŠ¥ ìµœì í™”

### ìºì‹± ì „ëµ

```typescript
// utils/aiCache.ts
class AICache {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly TTL = 5 * 60 * 1000; // 5ë¶„

  set(key: string, data: any): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  get(key: string): any | null {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  clear(): void {
    this.cache.clear();
  }
}

export const aiCache = new AICache();
```

### ë°°ì¹˜ ì²˜ë¦¬

```typescript
// utils/batchProcessor.ts
export class BatchProcessor {
  private queue: Array<() => Promise<any>> = [];
  private processing = false;
  private batchSize = 5;
  private delay = 1000; // 1ì´ˆ ê°„ê²©

  async add<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
          return result;
        } catch (error) {
          reject(error);
          throw error;
        }
      });

      if (!this.processing) {
        this.process();
      }
    });
  }

  private async process(): Promise<void> {
    this.processing = true;

    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, this.batchSize);
      
      try {
        await Promise.all(batch.map(task => task()));
      } catch (error) {
        console.error('Batch processing error:', error);
      }

      if (this.queue.length > 0) {
        await new Promise(resolve => setTimeout(resolve, this.delay));
      }
    }

    this.processing = false;
  }
}

export const batchProcessor = new BatchProcessor();
```

## ë¹„ìš© ê´€ë¦¬

### í† í° ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

```typescript
// utils/tokenMonitor.ts
export class TokenMonitor {
  private usage = {
    totalTokens: 0,
    totalCost: 0,
    requests: 0
  };

  recordUsage(tokens: number, model: string): void {
    this.usage.totalTokens += tokens;
    this.usage.requests += 1;
    
    // GPT-4o ë¹„ìš© ê³„ì‚° (ì˜ˆì‹œ)
    const costPer1kTokens = 0.005; // ì‹¤ì œ ë¹„ìš©ìœ¼ë¡œ ìˆ˜ì • í•„ìš”
    this.usage.totalCost += (tokens / 1000) * costPer1kTokens;

    // ë¡œê¹…
    console.log(`Token usage: ${tokens}, Total: ${this.usage.totalTokens}, Cost: $${this.usage.totalCost.toFixed(4)}`);
  }

  getUsage() {
    return { ...this.usage };
  }

  reset(): void {
    this.usage = {
      totalTokens: 0,
      totalCost: 0,
      requests: 0
    };
  }
}

export const tokenMonitor = new TokenMonitor();
```

### ë¹„ìš© ì œí•œ ì„¤ì •

```typescript
// utils/costLimiter.ts
export class CostLimiter {
  private dailyCost = 0;
  private lastReset = new Date().toDateString();
  private readonly dailyLimit = 10; // $10 ì¼ì¼ í•œë„

  canMakeRequest(estimatedCost: number): boolean {
    this.checkDailyReset();
    
    if (this.dailyCost + estimatedCost > this.dailyLimit) {
      return false;
    }
    
    return true;
  }

  recordCost(cost: number): void {
    this.checkDailyReset();
    this.dailyCost += cost;
  }

  private checkDailyReset(): void {
    const today = new Date().toDateString();
    if (today !== this.lastReset) {
      this.dailyCost = 0;
      this.lastReset = today;
    }
  }

  getDailyUsage(): { cost: number; limit: number; remaining: number } {
    this.checkDailyReset();
    return {
      cost: this.dailyCost,
      limit: this.dailyLimit,
      remaining: this.dailyLimit - this.dailyCost
    };
  }
}

export const costLimiter = new CostLimiter();
```

## ğŸ›ï¸ ADR (Architecture Decision Records)

### ADR-001: OpenAI GPT-4o ì„ íƒ
**ë‚ ì§œ**: 2025-01-14  
**ìƒíƒœ**: ìŠ¹ì¸ë¨  
**ì»¨í…ìŠ¤íŠ¸**: ê°ì • ê¸°ë°˜ ìº¡ì…˜ ìƒì„±ì„ ìœ„í•œ AI ëª¨ë¸ ì„ íƒ  
**ê²°ì •**: GPT-4oì˜ ë†’ì€ í’ˆì§ˆê³¼ ë¹ ë¥¸ ì‘ë‹µ ì†ë„ë¡œ ì„ íƒ  
**ê²°ê³¼**: ì•ˆì •ì ì´ê³  í’ˆì§ˆ ë†’ì€ ìº¡ì…˜ ìƒì„±

### ADR-002: Edge Functionsì—ì„œ AI ì²˜ë¦¬
**ë‚ ì§œ**: 2025-01-14  
**ìƒíƒœ**: ìŠ¹ì¸ë¨  
**ì»¨í…ìŠ¤íŠ¸**: AI API í˜¸ì¶œ ìœ„ì¹˜ ì„ íƒ  
**ê²°ì •**: Supabase Edge Functionsì—ì„œ AI API í˜¸ì¶œí•˜ì—¬ ë³´ì•ˆ ê°•í™”  
**ê²°ê³¼**: API í‚¤ ë³´ì•ˆ ë° ì„±ëŠ¥ ìµœì í™”

## ğŸ“‹ Changelog

| ë‚ ì§œ | ë²„ì „ | ìš”ì•½ |
|------|------|------|
| 2025-01-14 | v1.0.0 | AI í†µí•© ê°€ì´ë“œ ì´ˆê¸° ì‘ì„± |
| 2025-01-14 | v1.1.0 | í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ë° ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€ |
| 2025-01-14 | v1.2.0 | ì„±ëŠ¥ ìµœì í™” ë° ë¹„ìš© ê´€ë¦¬ ì¶”ê°€ |
